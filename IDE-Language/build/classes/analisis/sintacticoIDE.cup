package analisis;

import java_cup.runtime.*;
import analisis.semantic.*;
import analisis.semanticObjects.*;
import languageConstants.languageConstants;

parser code {:

	private semanticManager semanticM;
	private operation ops = new operation();
	languageConstants languageC = new languageConstants();

	public sintactico(Lexer lex, semanticManager semanticM){
		super(lex);
		this.semanticM = semanticM;
	}

	public void syntax_error(Symbol cur_token) {
		String message = "Estructura invalida en Columna: " + cur_token.right
			 + " Fila: " + cur_token.left + " , token: " + cur_token.value;
		System.out.println(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>><<<<<");	 
		System.out.println(message);
		System.out.println("<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<");
	}
:}

/* Terminal */
terminal String NamInt, NamFloat, NamBoolean, NamString, NamMain, NamIf, NamWhile;
terminal String PrintN, PrintS, BreakCom, Mas, Menos, Por, Div, Mayor, Menor, Igual, And;
terminal String Or, Asignacion, EndCom, ParAbierto, ParCerrado, Coma, Booleano, Cadena;
terminal String Entero, Decimal, Identificador, NamElse, Diferente, CorCerrado, CorAbierto;

/* Non terminal */
non terminal String CODIGO, INICIO_CODIGO;
non terminal Boolean IF_ELSE, MAIN_IDE, MAIN_BODY, MAIN_FUNCION, CUERPO_CODIGO;
non terminal Boolean IF_ELSE_FUNCION, INSIDE_CODE, WHILE_FUNCION, PRINT_FUNCION, PRINT_OPTION;
non terminal noDefine OPERACION, CONCATENAR;
non terminal variableObject ID_VAR, ID_STRING;
non terminal Integer DECLARAR_STRING, DECLARACION_VAR; 
/*Precedence*/
precedence left ParAbierto, ParCerrado;
precedence left Mas, Menos;
precedence left Por, Div;
precedence left Menor, Mayor;
precedence left Igual, Diferente;
precedence left And, Or;

//start with DECLARACION_VAR;

start with INICIO_CODIGO;

INICIO_CODIGO	::= CODIGO
					;

CODIGO 			::=	CUERPO_CODIGO CODIGO					{: :}
					| MAIN_IDE:e CorCerrado					{: semanticM.breakOutOfWhile(e); :}
					;

CUERPO_CODIGO	::=	DECLARACION_VAR EndCom		{: :}
					| DECLARAR_STRING EndCom	{: :}
					;

MAIN_IDE		::=	NamMain ParAbierto ParCerrado CorAbierto MAIN_BODY:e	{: RESULT = semanticM.findBreak(e, false); :}
					;

MAIN_BODY		::=	MAIN_BODY MAIN_FUNCION:e	{: RESULT = semanticM.findBreak(e, false); :}
					| MAIN_FUNCION:e			{: RESULT = semanticM.findBreak(e, false); :}
					;

MAIN_FUNCION	::=	IF_ELSE_FUNCION:e				{: RESULT = semanticM.findBreak(e, false); :}
					| PRINT_FUNCION:e				{: RESULT = semanticM.findBreak(e, false); :}
					| WHILE_FUNCION:e				{: RESULT = semanticM.findBreak(e, false); :}
					| DECLARACION_VAR EndCom		{: RESULT = false; :}
					| DECLARAR_STRING EndCom		{: RESULT = false; :}
					| ID_VAR:e EndCom				{: semanticM.modifyValue(e);  RESULT = false; :}
					| ID_STRING:e EndCom			{: semanticM.modifyValue(e);  RESULT = false; :}
					| BreakCom EndCom				{: RESULT = true; :}
					;

DECLARACION_VAR	::=	DECLARACION_VAR:e1 Coma ID_VAR:e2	{: semanticM.addVariableToList(e1, e2); RESULT = e1; :}
					| NamInt ID_VAR:e					{: semanticM.addVariableToList(languageC.INTEGER, e); RESULT = languageC.INTEGER; :}
					| NamBoolean ID_VAR:e				{: semanticM.addVariableToList(languageC.BOOLEAN, e); RESULT = languageC.BOOLEAN; :}
					| NamFloat ID_VAR:e					{: semanticM.addVariableToList(languageC.FLOAT, e); RESULT = languageC.FLOAT; :}
					;

ID_VAR			::=	Identificador:e								{: RESULT = ops.tempVar(e, null); :}
					| Identificador:e1 Asignacion OPERACION:e2 	{: RESULT = ops.tempVar(e1, e2); :}
					;

OPERACION		::=	OPERACION:e1 Mas OPERACION:e2 			{: RESULT = ops.arithmeticOp(languageC.ADD,	e1, e2); :}
					| OPERACION:e1 Menos OPERACION:e2 		{: RESULT = ops.arithmeticOp(languageC.LESS,e1, e2); :}
					| OPERACION:e1 Por OPERACION:e2 		{: RESULT = ops.arithmeticOp(languageC.MUL,	e1, e2); :}
					| OPERACION:e1 Div OPERACION:e2 		{: RESULT = ops.arithmeticOp(languageC.DIV,	e1, e2); :}
					| OPERACION:e1 Menor OPERACION:e2 		{: RESULT = ops.logicOp(languageC.MENOR_Q, 	e1, e2); :}
					| OPERACION:e1 Mayor OPERACION:e2 		{: RESULT = ops.logicOp(languageC.MAYOR_Q, 	e1, e2); :}
					| OPERACION:e1 Igual OPERACION:e2 		{: RESULT = ops.logicOp(languageC.IGUAL, 	e1, e2); :}
					| OPERACION:e1 Diferente OPERACION:e2 	{: RESULT = ops.logicOp(languageC.DIFERENTE, e1, e2); :}
					| OPERACION:e1 Or OPERACION:e2 			{: RESULT = ops.logicOp(languageC.OR, 		e1, e2); :}
					| OPERACION:e1 And OPERACION:e2			{: RESULT = ops.logicOp(languageC.AND, 		e1, e2); :}
					| ParAbierto OPERACION:e ParCerrado		{: RESULT = e; :}
					| Entero:e								{: RESULT =  new noDefine(Double.parseDouble(e), languageC.DOUBLE_AUX); :}
					| Decimal:e								{: RESULT =  new noDefine(Double.parseDouble(e), languageC.DOUBLE_AUX); :}
					| Identificador:e 						{: RESULT = semanticM.returnNoDefineObject(e); :}
					| Booleano:e 							{: RESULT = new noDefine(Boolean.valueOf(e), languageC.BOOL_AUX); :}
					;

DECLARAR_STRING	::=	DECLARAR_STRING:e1 Coma ID_STRING:e2	{: semanticM.addVariableToList(e1, e2); RESULT = e1; :}
						| NamString ID_STRING:e					{: semanticM.addVariableToList(languageC.STRING, e); RESULT = languageC.STRING; :}
						;

ID_STRING		::=	Identificador:e1 Asignacion CONCATENAR:e2	{: RESULT = ops.tempVar(e1, e2); :}
					;

CONCATENAR		::= CONCATENAR:e1 Mas Cadena:e2				{: RESULT = ops.stringOp(e1, new noDefine(e2, languageC.STRING_AUX)); :}
					| CONCATENAR:e1 Mas OPERACION:e2 		{: RESULT = ops.stringOp(e1, e2); :}
					| ParAbierto CONCATENAR:e ParCerrado	{: RESULT = e; :}
					| Cadena:e	 							{: RESULT = new noDefine(e, languageC.STRING_AUX); :}
					;

IF_ELSE_FUNCION	::= IF_ELSE:e 							{: RESULT = semanticM.findBreak(e, false); :}
					| IF_ELSE:e1 NamElse INSIDE_CODE:e2	{: RESULT = semanticM.findBreak(e1, e2); :}
					;

IF_ELSE 		::= IF_ELSE:e1 NamElse NamIf ParAbierto OPERACION:e2 ParCerrado INSIDE_CODE:e3 	{: semanticM.correctIfOperator(e2); RESULT = semanticM.findBreak(e1, e3); :}
					| NamIf ParAbierto OPERACION:e1 ParCerrado INSIDE_CODE:e2					{: semanticM.correctIfOperator(e1); RESULT = semanticM.findBreak(e2	, false); :}
					;

INSIDE_CODE		::= CorAbierto MAIN_BODY:e CorCerrado		{: RESULT = semanticM.findBreak(e, false); :}
					;

WHILE_FUNCION	::= NamWhile ParAbierto OPERACION:e1 ParCerrado INSIDE_CODE:e2 	{: semanticM.correctIfOperator(e1); RESULT = semanticM.findBreakInWhile(e2); :}
					;

PRINT_FUNCION	::= PRINT_OPTION ParAbierto CONCATENAR:e ParCerrado EndCom	{: semanticM.correctStringOperator(e); :}
					;

PRINT_OPTION	::= PrintN 		{: :}
					| PrintS	{: :}
					;
